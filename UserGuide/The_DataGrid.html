<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"></meta><link href="/Abacus/exigo.css" rel="stylesheet"></link></head><body><header><a href="/Abacus/"><img height="80px" src="/Abacus/Images/AbacusLight.svg" width="auto"></img></a><nav><a href="/Abacus/UserGuide">User Guide</a><a href="/Abacus/ObjectReference">Object Reference</a><a href="/Abacus/FunctionReference">Function Reference</a></nav></header><main><p>The DataGrid component implements a high-performance, virtual HTML table.</p><h2>Design Goals</h2><p>The Abacus DataGrid is primarily designed for the viewing, editing and manipulation of tables. It is explicitly NOT designed to be a vehicle for presentation, reporting, or spreadsheets.  This means columns are expected to be the same type and rows are all the same height. Columns are named, rows are not. (The programmer can of course simulate row names by properly defining the first column.) The font is uniform across all cells. Cells are never spanned. The scroll and edit experience is designed to be as close to common spreadsheet applications as possible.</p><p>The Abacus DataGrid is not a general purpose grid like the <code>⎕WC</code> grid, but rather a special purpose grid that one might build on top of <code>⎕WC</code> grid.</p><p>At the Carlisle Group we have two primary uses that we are coding for. The first is viewing and manipulating relatively large database tables with millions of rows and/or hundreds, even thousands, of columns. The second is creating, viewing and editing smaller metadata tables, like table schemas, configuration tables, and name/value pairs.   The DataGrid can easily handle arbitrarily large tables, as long as the raw data values fit in memory. Out of the box it supports editing individual cells, cell selection and cut/copy/paste. It supports inserting, deleting, and moving rows and columns. It supports renaming columns. It supports find and replace.</p><p>Column types may be Char, Date, Int, Float, DecN, Select, MultiSelect and CheckBox. Other types will no doubt be added in the future. Adding new types is easy - we just need a function to format the type for display, verify the type, and possibly edit the type if it cannot be edited in-cell with a simple text string. In fact, the programmer may effectively add a type by simply defining the appropriate handler functions (see below).   </p><p>Char columns support autocomplete.</p><p>An additional requirement is friction-free editing of column headers. Most of the time, if the ability to rename columns is required, then using a menu or shortcut key and having a dialog box pop up is sufficient and desirable. However in some cases it useful to be able to edit column headers just like regular cells. Related to this is the ability to have multiple row headers and titles for header rows.   </p><h2>Implementation</h2><p>We use the HTML table element. We investigated using just <code>&lt;div&gt;</code>s with CSS <code>display:grid</code>. Both solutions perform well in terms of scrolling speed, but the table solution had a slight edge. While tables are more complex, they are of course more semantic for the task at hand, though that may not be worth much  considering that the datagrid is virtualized, and our primary platform is the desktop. More importantly, the structure of  <code>&lt;table&gt;</code>, <code>&lt;thead&gt;</code>, <code>&lt;tbody&gt;</code> etc., is quite useful and would have to be somewhat emulated if a pure <code>&lt;div&gt;</code> solution was used. The additional tags are not a deal breaker as we only render what fits on the screen, plus a little overage. Finally, tables have better grid line and border support than <code>display:grid</code>.          ## Running the Tests ##</p><p>You will need projects Rumba and Provanto to run the grid and the tests. Rumba is not an official dependency of Abacus at this point in time. To run the tests you then do:</p><pre><code>      )CS #.Abacus      Main.RunTests Tests.DataGridSuite1 Main.DataGrid~~~ We are still working on some race or timing issues, so sometimes a test will fail for no apparent reason.You can start the test application but not run the tests by giving a neg 1 left arg:</code></pre><pre><code>      ¯1 Main.RunTests Tests.DataGridSuite1 Main.DataGrid</code></pre><p>You can then run tests one at time:</p><pre><code>      Tests.DataGridQuite.TestCutAndPaste 00</code></pre><p>Often a failing test will run fine like this.</p><h2>Properties</h2><p><span class="extrastrong">er settable properties includ</span></p><p><code>Columns</code>: a vector of column specification namespaces, containing <code>Name</code>, <code>Type</code>, Value, etc. (See below)</p><p><code>ReadOnly</code>: Boolean. Marks the entire Values area of the DataGrid as read-only. Defaults to <code>0</code>. This is the default value of not specified at the column level.    <code>RowNumbers</code>: Boolean. Display row numbers or not. Default to <code>1</code>.</p><p><code>InsertRows</code>: Boolean. Allow or disallow row insertion. If allowed, then rows may also be moved and deleted. Defaults to <code>1</code>.</p><p><code>InsertColumns</code>: Boolean. Allow or Disallow column insertion. If allowed, then columns may also be moved, renamed, or deleted, unless otherwise specified at the column level. Defaults to <code>0</code>.</p><p><code>RowMinimum</code>: Minimum number of rows to display regardless of data size. Only applicable if InsertRows is 1. This just gives nice grid lines when the grid is empty or very small. When deleting rows, a new empty row is appended if necessary to keep the minimum   </p><p><code>TopLeftCell</code>: The row and column index into Values of the upper left corner of the visible grid.</p><p><code>ActiveCell</code>: The row and column index into Values of the current cell.</p><p><code>WindowSize</code>: Number of full rows and columns visible. (Read-only)</p><h2>Column Specification Namespace</h2><p>The <code>Columns</code> property is a vector of column specification namespaces, one for each column.       The column specification namespace contains various properties, all of which default and may be omitted. Most of the time the programmer will probably want to specify the column name, value, type, and perhaps a format string here or there. Otherwise the defaults should generally suffice. </p><p>The properties of the column specification namespace are:</p><p><span class="extrastrong">ame`**: The column name. This defaults to spreadsheet-style column names A, B, C, e</span></p><p><code>Type</code>: The column type. Current supported types are Char, VarChar, Int, Float, Date, Dec[1,2,3], Select, MultiSelect, and CheckBox. If the type is provided and   the Value property is provided, they must correspond. If no type and no value is provided, the type defaults to VarChar. If no type is provided but a Value property is provided, the type is inferred from the value.   </p><p><code>Value</code>: The values in the column. Must all be the same length.</p><p><code>HeaderValues</code>: Specifies column titles. This defaults to <code>Name</code>. For multi-row headers, may be a vector of vectors.</p><p><code>HeaderRowTitles</code>: Specifies title or titles in the upper left corner. Defaults to empty/blank.  </p><p><code>ReadOnly</code>: the column is read-only. Defaults to the value of the <code>ReadOnly</code> flag for whole grid. </p><p><code>CanDelete</code>: The column may be deleted. Defaults to the value of <code>InsertColumns</code>. </p><p><code>CanRename</code>: The column may be renamed. Defaults to the value of <code>InsertColumns</code>.</p><p><code>Null</code>: A null value. For numerics, if a null value is in the domain of the column type, then the FormatString handles how it is displayed. For example, the Date type uses 0 for null, and formats 0s as blank.  If the null value is <code>⎕NULL</code> or <code>⍬</code> or some other value then it will automatically be displayed as blank or empty. Null values are also used to replace deleted cell contents. For large data sets, try to keep the null value in the domain of the column.</p><p><code>Default</code>: A default value for use when inserting a new row. This may or may not be the same as the null value. </p><p><code>List</code>: A list of character vectors for Select and MultiSelect types, and for Char columns that support autocomplete.    <code>FormatString</code>: A format string (left arg to <code>⎕FMT</code>) to be used by the <code>OnFormat</code> function. Applicable only to numeric values and dates. Usual use case is that a format string might be specified for Int and Float columns.</p><p><code>FirstFormatString</code>: For the first visible row only.  </p><p><code>OnFormat</code>: A function that formats the column for display in HTML. The default value uses the <code>FormatString</code> with <code>⎕FMT</code>, when appropriate, to format the value. The right argument provided to the function is the vector of column values to be formatted. The left argument is the column specification namespace.  This should rarely need to be specified, as  setting <code>FormatString</code> should handle most cases. However, there may be times when complete control is desired.  </p><p><code>OnParse</code>: A function that parses the text entered when editing a cell, and converts it to the appropriate data type. This function takes a simple text string as its right argument, and the column specification namespace as its left argument. It must return a 3-item vector containing a boolean to signify success (1) or failure (0), the parsed value, and an error message. Like <code>OnFormat</code>, this should rarely need to be specified. It may be needed if <code>OnFormat</code> is specified in such a way  that the default parsing insufficient. If it is specified, there is the opportunity here to modify the value, say removing all blanks, uppercasing, or moving a decimal place.    </p><p><code>OnValidate</code> A function that provides additional validation to the <code>OnParse</code> function. This function takes the parsed result as its right argument and the column specification namespace as its left argument, and then produces a result  in the form as <code>OnParse</code>. This handler is designed more for common usage than <code>OnFormat</code> or <code>OnParse</code>. It is applied after OnParse is called, and we know that we have a valid type for the column. It allows for both validation and for possible modification of the value (like <code>OnParse</code>), like uppercasing or scaling. </p><h2>Column Types</h2><p>Column types are fully defined by the <code>OnFormat</code>, <code>OnParse</code>, and <code>OnValidate</code> handler functions. This means that you can define new types by simply defining these functions. For example, we can make up a type named <code>RGB</code> which will be stored as a 3 item numeric vector of integers from 0 to 255 by defining:</p><pre><code>OnFormatRGB←{     {1↓,' ','ZI3'⎕FMT ⍵}¨⍵ }OnParseRGB←{     b v←⎕VFI ⍵     0=≢b:1 v''     (v≡⌊v)∧(b≡3⍴1)∧∧/(v≥0)∧v≤255:1 v''     0 0 'Value must be 3 integers from 0 to 255.' }</code></pre><h2>Header Specification Namespace</h2><p>The <code>Headers</code> property is a vector of of header specification namespaces, corresponding to the number of rows in HeaderValues property. </p><p>The properties of the header specification namespace are:</p><p><code>Title</code>: A title for the header row. For a typical DataGrid with a one-row header, this is the value placed in the upper left corner of the grid, above the row numbers. Header row titles will only display if <code>RowNumbers</code> is set to <code>1</code>.  Defaults to an empty vector.</p><p><code>ReadOnly</code>: Indicates whether or not header row titles may be edited in-cell like regular values. Default to <code>1</code>. This is independent of column renaming. It is left up to the calling application to decide if editing a header row renames the column.   </p><p><code>List</code>: A list of char vectors for autocomplete. Only applicable if ReadOnly is <code>0</code>.</p><h2>Methods</h2><p>There is only one method: <code>Refresh</code>.</p><p>Properties are NOT covered by getters and setters, so the <code>Refresh</code> method must be run after one or more properties has been changed.</p><h2>Events</h2><p>The DataGrid supports events. Event handlers may be attached to events:</p><pre><code>      g.OnCellChange←'MyFoo'  </code></pre><p>Events always fire and report the state of things after the event has taken place, unless the event is named Before[event]. For example there is a <code>CellValueChange</code> event and a <code>BeforeCellValueChange</code> event.  Note that events are events are explicitly NOT named in the past tense  in an attempt to signify that they fire after the event has taken place.  </p><p>The left argument passed to the event handler is a reference to the DataGrid. The right argument is the event message namespace. This namespace contains the name of the event and other values of interest. In some cases there are no other values of interest as the reference to the DataGrid itself has everything you need to know.</p><p>If the event is a "before" event then the event handler may modify the event message (to a limited extent), and thus alter aspects of the event that will take place. For example, on a <code>BeforeCellValueChange</code> event, we may want to force the entered text to be uppercase, or have no spaces. Furthermore, the result of a "before" event handler may return a <code>0</code> to let the event occur, or a <code>1</code> to prevent the event. </p><p>Events include:</p><p><code>Refresh</code>: Any visible aspect of the DataGrid has changed. This could be editing a cell, scrolling, clicking to move the active cell, selecting cells, renaming a column, inserting row etc. (We may want a way to throttle this event, or maybe not even implement it.)</p><p><code>ActiveCellChange</code>: The current cell location has changed.    <code>Scroll</code>: The DataGrid has been scrolled in some way. The visible rows and columns have changed. The CellIndex property has changed.</p><p><code>Resize</code>: The DataGrid has been resized.  </p><p><code>CellValueChange</code>: The value of a cell (the Values property) or range of cells has been changed by in-cell editing or cut/copy/paste.</p><p><code>BeforeCellValueChange</code>: A cell or range of cells is about to be changed by in-cell editing or cut/copy/paste.</p><p><code>RenameColumn</code>: A column as been renamed. </p><p><code>BeforeRenameColumn</code>: A column is about to renamed.'</p><p><code>InsertRow</code>: A new row has been inserted (or added by scrolling down below the last row).</p><p><code>BeforeInsertRow:</code> A new row is about to be inserted.</p><p><code>DeleteRow</code>: A row has been deleted.</p><p><code>BeforeDeleteRow</code>: A row s about to be deleted.</p><p><code>InsertColumn</code> A new column has been inserted.</p><p><code>BeforeInsertColumn</code>: A new column is about to be inserted.</p><p><code>DeleteColumn</code>: A column has been deleted.   <code>BeforeDeleteColumn</code>: A column is about to be deleted.</p><p><code>BeforeHeaderValyeChange</code>:</p><p><code>HeaderValueChange</code>:   </p></main><footer></footer></body></html>
