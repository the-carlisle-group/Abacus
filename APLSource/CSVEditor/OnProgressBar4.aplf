 OnProgressBar4←{
     ⍝ A more functional approach to progress bars.
     ⍝ A deterministic example
     d←⍵.Document
     ⍝ We need a function that is called on each iteration,
     ⍝ to do do the work we want to do. In this case, just accumulating the time
     ⍝ spent during a delay, and updating the progress bar status:
     f←{
         ⍝ ⍺ ←→ Progress Bar
         ⍝ ⍵ ←→ Namesapce
         t←⎕DL 0.2
         ⍵.TotalTime+←t
         ⍺.Status←'Total time so far: ',(⍕⍵.TotalTime),' after iteration ',⍕⍺.Iteration
         t
     }
     ⍝ We need a namespace (or var! - then no accumulation, but still useful)
     ⍝ that will be the right argument to f.
     ⍝ This will have in it any info or data the function f might need
     ⍝ from any intialization variables to a file tie number, etc:
     s←(TotalTime:0)
     ⍝ The left argument supplied to f is the progress bar instance.
     ⍝ We can use this to update the status, and to inquire about
     ⍝ what iteration we are currently on.
     ⍝ The result of this function can be anything and is passed through.
     ⍝ That is all we need, and now we can run the function under a progress bar
     ⍝ using the Run operator.
     ⍝ First create a new progress bar:
     p←d A.ProgressBar.New'Progress Example #4' 25 1
     ⍝ Then use the Run operator:
     rc rv←p f A.ProgressBar.Run s
     ⎕←rc
     ⎕←rv
     ⍝ rc is either 'Resume' 'Cancel' or 'Truncate'
     ⍝ rv is a vector or results for each completed iteration.
     ⍝ Note that in this case +/rv should correpsond to s.TotalTime
     ⍝ This demonstrates two different ways of accumulating results.
     ⍝ Note that if the operation is truncated, or even canceled,
     ⍝ the results up until the cancelation are available in rv or in s.
     0
 }
