 OnProgressBar5←{
     ⍝ A more functional approach to progress bars.
     ⍝ Indeterminate example.
     d←⍵.Document
     ⍝ We need a function that is called on each iteration,
     ⍝ to do do the work we want to do. In this case, just accumulating the time
     ⍝ spent during a delay, and updating the progress bar status.
     ⍝ As this case is non-determinitic, we need a test know when to exit.
     ⍝ We assign the Done property of the Progress Bar to 1.
     f←{
         ⍝ ⍺ ←→ Progress Bar
         ⍝ ⍵ ←→ Namesapce
         t←⎕DL 0.2
         ⍵.TotalTime+←t
         ⍺.Status←'Total time so far: ',(⍕⍵.TotalTime),' after iteration ',⍕⍺.Iteration
         ⍺.Exit←⍵.TotalTime>10
         t
     }
     ⍝ We need a namespace (or var! - then no accumulation, but still useful)
     ⍝ that will be the right argument to f.
     ⍝ This will have in it any info or data the function f might need
     ⍝ from any intialization variables to a file tie number, etc:
     s←(TotalTime:0)
     ⍝ The left argument supplied to f is the progress bar instance.
     ⍝ We can use this to update the status, and to inquire about
     ⍝ what iteration we are currently on.
     ⍝ The result of this function can be anything and is passed through
     p←d A.ProgressBar.New'Progress Example #5' 0 1
     rc rv←p f A.ProgressBar.Run s
     ⍝ rc is either  0 1 2
     ⍝ rv is a vector or results for each completed iteration.
     ⍝ Note that +/rv should correpsond to s.TotalTime
     ⍝ This exemplifies two different ways of accumulating results
     ⍝ Note that if the operation is truncated, or even canceled,
     ⍝ the results up until the cancelation are available in rv or in s.
     0
 }
